
import React from 'react';
import { useTopics } from '@/contexts/TopicsContext';
import { useLanguage } from '@/contexts/LanguageContext';
import { ScrollArea, ScrollBar } from '@/components/ui/scroll-area';
import { Card, CardContent } from '@/components/ui/card';
import MathFormula from '@/components/MathFormula';
import LatexText from '@/components/LatexText';

const MainPanel: React.FC = () => {
  const { selectedTopic } = useTopics();
  const { t } = useLanguage();

  if (!selectedTopic) return null;

  // Helper function to render content based on topic ID
  const renderTopicContent = () => {
    switch (selectedTopic.id) {
      case 'shaders':
        return (
          <>
            <h2 className="text-2xl font-bold mb-4">{t('shadersTitle')}</h2>
            {/* <p className="mb-4">{t('shadersContent')}</p> */}

            <p className = "mb-4">Шейдер представляет собой компьютерную программу, которая использует средства графического процессора для рендеринга изображения. Шейдеры пишут на особых языках программирования, их компиляция происходит в инструкции для графического процессора.</p>
            
            
            {/* <div className="bg-gray-100 p-4 rounded-md w-full min-w-0">
              <code>
                <pre className="whitespace-pre-wrap break-all">
                  {`// Example GLSL shader
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    fragColor = vec4(uv.x, uv.y, 0.5, 1.0);
}`}
                </pre>
              </code>
            </div> */}
            
            
            
            <p className = "mb-4">Программы, работающие с трёхмерной графикой и видео, используют шейдеры для определения параметров геометрических объектов или изображения, для изменения изображения (для создания эффектов сдвига, отражения, преломления, затемнения с учётом заданных параметров света, для наложения текстур на геометрические объекты и т.д.).</p>

            <p className = "mb-4">Ранее разработчики игр реализовывали алгоритм создания изображений из геометрических объектов (рендеринг) вручную: составляли алгоритм определения видимых частей сцены и наложения текстур, составляли алгоритмы, создающие нестандартные видеоэффекты. Для ускорения рисования некоторые алгоритмы были реализованы на аппаратном уровне с помощью видеокарты. Разработчики игр могли использовать алгоритмы, реализуемые видеокартой, но не могли заставить видеокарту исполнять свои собственные алгоритмы, например, для создания нестандартных эффектов. Нестандартные алгоритмы исполнялись на центральном процессоре, который был более медленным для задач обработки графики по сравнению с процессорами видеокарты. Рассмотрим два примера.</p>

            <p className = "mb-4">Решением таких проблем стало добавление в видеокарты аппаратных алгоритмов, востребованных для разработчиков. Вскоре стало ясно, что так реализовать все алгоритмы невозможно и нецелесообразно. Разработчикам дали доступ к видеокарте — это позволило собирать блоки графического процессора в произвольные конвейеры, реализующие разные алгоритмы. Программы, предназначенные для выполнения на процессорах видеокарты, получили название «шейдеры». Были разработаны специальные языки для составления шейдеров. Теперь в видеокарты загружались не только данные о геометрических объектах («геометрия»), текстуры и другие данные, необходимые для рисования (формировании изображения), но и инструкции для GPU.
            До начала применения шейдеров использовались процедурная генерация текстур (например, применялась в игре Unreal для создания анимированных текстур воды и огня) и мультитекстурирование (на нём был основан язык шейдеров, применявшийся в игре Quake 3). Эти механизмы не обеспечивали такой же гибкости, как шейдеры.</p>

            <p className = "mb-4">С появлением перенастраиваемых графических конвейеров появилась возможность проводить на GPU математические расчёты (GPGPU). Наиболее известные механизмы GPGPU — Nvidia CUDA, OpenCL от Microsoft DirectCompute, Vulkan от Khronos Group.</p>

            <p className = "mb-4">Сначала видеокарты оснащали несколькими специализированными процессорами, поддерживающими разные наборы инструкций. Шейдеры делили на три типа в зависимости от того, какой процессор будет их исполнять (в зависимости от того, какие наборы инструкций доступны):</p>

            <ol className="list-decimal mb-4 ml-6">
              <li>вершинные (vertex shader);</li>
              <li>геометрические (geometry shader);</li>
              <li>пиксельные или фрагментные (pixel shader, fragment shader).</li>
            </ol>

            <p className = "mb-4">Затем видеокарты стали оснащать универсальными процессорами (GPU), поддерживающими наборы инструкций всех трёх типов шейдеров. Деление шейдеров на типы сохранилось для описания назначения шейдера. Появилась возможность выполнения на GPU вычислений общего назначения, не связанных только с компьютерной графикой, например майнинг криптовалют, оюучение нейронных сетей.</p>

            <p className = "mb-4">Вершинный шейдер оперирует данными, связанными с вершинами многогранников, например, с координатами вершины (точки) в пространстве, с текстурными координатами, с цветом вершины, с вектором касательной, с вектором бинормали, с вектором нормали. Вершинный шейдер может использоваться для видового и перспективного преобразования вершин, для генерации текстурных координат, для расчёта освещения и т.д.</p>

            <p className = "mb-4">Геометрический шейдер, в отличие от вершинного, способен обработать не только одну вершину, но и целый примитив. Примитивом может быть отрезок (две вершины) и треугольник (три вершины), а при наличии информации о смежных вершинах для треугольного примитива может быть обработано до шести вершин. Геометрический шейдер способен генерировать примитивы «на лету» (не задействуя при этом центральный процессор).</p>

            <p className = "mb-4">Пиксельный шейдер работает с фрагментами растрового изображения и с текстурами — обрабатывает данные, связанные с пикселями (например, цвет, глубина, текстурные координаты). Пиксельный шейдер используется на последней стадии графического конвейера для формирования фрагмента изображения.</p>

            <h6 className="font-bold mb-4">Преимущества шейдеров:</h6>

            <ol className="list-decimal mb-4 ml-6">
              <li>возможность составления любых алгоритмов (гибкость, упрощение и удешевление цикла разработки программы, повышение сложности и реалистичности визуализируемых сцен);</li>
              <li>повышение скорости выполнения (по сравнению со скоростью выполнения того же алгоритма, исполняемого на центральном процессоре)</li>
            </ol>

            <h6 className="font-bold mb-4">Недостатки шейдеров:</h6>
            
            <ol className="list-decimal mb-4 ml-6">
              <li>необходимость изучения нового языка программирования;</li>
              <li>существование различных наборов инструкций для GPU разных производителей.</li>
            </ol>

            <p className = "mb-4">Обычно языки для написания шейдеров предоставляют программисту специальные типы данных (матрицы, семплеры, векторы и др.), набор встроенных переменных и констант (для взаимодействия со стандартной функциональностью 3D API).</p>


            <h6 className="font-bold mb-4">Некоторые языки шейдеров:</h6>


            <ol className="list-decimal mb-4 ml-6">
              <li>GLSL(OpenGL Shading Language) - язык программирования шейдеров, описанный в стандарте OpenGL и основанный на версии языка C описанной в стандарте ANSI C. Язык поддерживает большинство возможностей ANSI C, поддерживает типы данных, часто применяемые при работе с трёхмерной графикой (векторы, матрицы);</li>
              <li>HSLS(High Level Shader Language) - высокоуровневый язык программирования шейдеров, разработанный для DirectX и похожий на язык C. Представляет собой надстройку над языком DirectX ASM. Позволяет использовать структуры, процедуры и функции.;</li>
              <li>DirectX ASM — низкоуровневый язык программирования шейдеров, разработанный для DirectX. Синтаксис языка схож с синтаксисом языка ассемблера для процессоров x86. Существует несколько версий языка, отличающихся друг от друга наборами поддерживаемых инструкций GPU и требованиями к оборудованию. Вершинный шейдер может состоять из 100—200 инструкций. Количество инструкций пиксельного шейдера более ограничено; например, в языке версии 1.4 пиксельный шейдер не может включать более 32-х инструкций;</li>
              <li>WebGL (Web-based Graphics Library) — кроссплатформенный API для отображения 3D-графики в браузере, разрабатываемый некоммерческой организацией Khronos Group. WebGL использует язык программирования шейдеров GLSL;</li>
              <li>Vulkan — кроссплатформенный API для 2D- и 3D-графики. Как и OpenGL, Vulkan позволяет с высокой производительностью отображать в реальном времени различные приложения с 3D-графикой, такие как игры или интерактивные книги на всех платформах, а также обеспечивает более высокую производительность и меньшую нагрузку на процессор.</li>
            </ol>


            <h2 className="text-2xl font-bold mb-4">Примеры простых шейдеров</h2>

            <h6 className="font-bold mb-4">Перемещение фигуры вокруг заданной точки</h6>

            <LatexText className = "mb-4">{`В данном примере происходит визуализация перемещения фигуры по кругу вокруг какого-то центра. Так как данный объект просто изображен на холсте (пространстве), т.е. является одним целым с холстом, то для его перемещения пошли на хитрость: координаты UV-плоскости (или же холста) просто меняются через встроенные функции $\\sin{x},\\,\\cos{x}$, т.е. сам объект является частью холста и расположен по середине, а сам холст совершает круговые движения. Движение UV-плоскости можно детально рассмотреть, если раскомментировать строчку в самом конце. Так же координаты холста нормализованы, т.е. каждая координата пикселя может принимать значения от $0$ до $1$ по абсциссе или ординате.`}</LatexText>

            <div className="bg-gray-100 p-4 rounded-md w-full min-w-0">
              <code>
                <pre className="whitespace-pre-wrap break-all">
                  {`#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

float box(in vec2 _st, in vec2 _size){
    _size = vec2(0.5) - _size*0.5;
    vec2 uv = smoothstep(_size,
                        _size+vec2(0.001),
                        _st);
    uv *= smoothstep(_size,
                    _size+vec2(0.001),
                    vec2(1.0)-_st);
    return uv.x*uv.y;
}

float cross(in vec2 _st, float _size){
    return  box(_st, vec2(_size,_size/4.)) +
            box(_st, vec2(_size/4.,_size));
}

void main(){
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    vec2 translate = vec2(cos(u_time),sin(u_time));
    st += translate*0.35;

    // color = vec3(st.x,st.y,0.0);

    color += vec3(cross(st,0.25));

    gl_FragColor = vec4(color,1.0);
}`}
                </pre>
              </code>
            </div>

            <h6 className="font-bold mb-4">Вращение фигуры вокруг центра</h6>

            <p className = "mb-4">В данном примере вращение объекта происходит в три этапа:</p>

            <ol className="list-decimal mb-4 ml-6">
              <li>Объект смещается в точку пересечения координат пространства, т.е. в точку $(0,\,0)$;</li>
              <li>Происходит вращение пространства на некоторый угол;</li>
              <li>Объект смещается обратно в середину холста.</li>
            </ol>

            <p className = "mb-4">Так же можно переместить сам центр координат в центр объекта, совершить поворот и вернуться в исходную точку.
В итоге мы получаем иллюзию вращения объекта относительно своего центра, хотя на самом деле происходят некоторые преобразования, которые не видны наблюдателю. Если же не совершать такую последовательность действий, то объект будет вращаться вокруг центра координат и даже пропадёт из виду.</p>

            <div className="bg-gray-100 p-4 rounded-md w-full min-w-0">
              <code>
                <pre className="whitespace-pre-wrap break-all">
                  {`#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 u_resolution;
uniform float u_time;

mat2 rotate2d(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
}

float box(in vec2 _st, in vec2 _size){
    _size = vec2(0.5) - _size*0.5;
    vec2 uv = smoothstep(_size,
                        _size+vec2(0.001),
                        _st);
    uv *= smoothstep(_size,
                    _size+vec2(0.001),
                    vec2(1.0)-_st);
    return uv.x*uv.y;
}

float cross(in vec2 _st, float _size){
    return  box(_st, vec2(_size,_size/4.)) +
            box(_st, vec2(_size/4.,_size));
}

void main(){
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    st -= vec2(0.5);
    st = rotate2d( sin(u_time)*PI ) * st;
    st += vec2(0.5);
    // color = vec3(st.x,st.y,0.0);
    
    color += vec3(cross(st,0.4));

    gl_FragColor = vec4(color,1.0);
}`}
                </pre>
              </code>
            </div>

            <h6 className="font-bold mb-4">Масштабирование фигуры</h6>

            <p className = "mb-4">Как и в предыдущих случаях, масштабирование фигуры происходит с помощью преобразований самого холста. Т.к. объект расположен по центру пространства, то для создания иллюзии масштабирования достаточно просто изменять ''рамку'' UV-пространства, т.е. менять максимальные и минимальные значения координат пикселей на холсте. При этом используется всё тот же трюк: перемещение объекта в центр координатной оси перед масштабированием, а затем возвращение объекта на исходное место после.</p>

            <div className="bg-gray-100 p-4 rounded-md w-full min-w-0">
              <code>
                <pre className="whitespace-pre-wrap break-all">
                  {`#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 u_resolution;
uniform float u_time;

mat2 scale(vec2 _scale){
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
}

float box(in vec2 _st, in vec2 _size){
    _size = vec2(0.5) - _size*0.5;
    vec2 uv = smoothstep(_size,
                        _size+vec2(0.001),
                        _st);
    uv *= smoothstep(_size,
                    _size+vec2(0.001),
                    vec2(1.0)-_st);
    return uv.x*uv.y;
}

float cross(in vec2 _st, float _size){
    return  box(_st, vec2(_size,_size/4.)) +
            box(_st, vec2(_size/4.,_size));
}

void main(){
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    st -= vec2(0.5);
    st = scale( vec2(sin(u_time*1.25)+1.25) ) * st;
    st += vec2(0.5);
    // color = vec3(st.x,st.y,0.0);

    color += vec3(cross(st,0.2));

    gl_FragColor = vec4(color,1.0);
}`}
                </pre>
              </code>
            </div>
            
          </>
        );

      case 'transformation-matrices':
        return (
          <>
            <h2 className="text-2xl font-bold mb-4">{t('transMatrTitle')}</h2>
            {/* <LatexText className="mb-4">
              {`${t('transMatrContent')} Here's an example of inline math: $x + y = z$ and 
              another one $\\vec{v} = (x, y, z)$. You can also use display mode math:`}
            </LatexText>
            
            <div className="my-4">
              <MathFormula 
                formula="\begin{bmatrix} x' \\ y' \\ z' \end{bmatrix} = \begin{bmatrix} a & b & c \\ d & e & f \\ g & h & i \end{bmatrix} \begin{bmatrix} x \\ y \\ z \end{bmatrix}"
                displayMode={true}
              />
            </div> */}

            {/* <h2 className="text-2xl font-bold mb-4">О матрицах преобразования</h2> */}

            {/* <LatexText className = "mb-4">
            Матрицы преобразований работают с однородными координатами точки, т.е. с расширенными координатами, где точка имеет $(n+1)$ координату в $n$-мерном пространстве.
            </LatexText> */}

          {/* <LatexText className = "mb-4">

          </LatexText> */}

          <LatexText className = "mb-4">
          {`Матрицы преобразований работают с однородными координатами точки, т.е. с расширенными координатами, где точка имеет $(n+1)$ координату в $n$-мерном пространстве. Например, пусть $A = (x, y) \\in \\mathbb{R}^2$ - произвольная точка на двумерной вещественной плоскости, её однородными координатами будет являться тройка координат $(x, y, t = 1)$, где $t$ - расширенная координата точки. Из проективной геометрии следует, что координата $t$ для бесконечно удалённых точек равняется $0$, в то время как у обычных точек (не бесконечно удалённых) координата $t$ равняется $1$. Отсюда следует, что матрица преобразования имеет размерность $3\\times3$ и работает сразу с тремя координатами: $x$, $y$ и $t$`}.
          </LatexText>

          <LatexText className = "mb-4">
          {`Если же точка $A = (x, y, z) \\in \\mathbb{R}^3$, то её расширенные координаты будут иметь вид: $A = (x, y, z, t = 1)$, а матрица преобразования будет размерности $4\\times4$ и работать с четырьмя координатами.`}
          </LatexText>

          <LatexText className = "mb-4">
          {`Рассмотрим следующий пример использования некоторой матрицы преобразования. Пусть $A = (a_1, a_2) \\in \\mathbb{R}^2$ - некоторая точка на вещественной двумерной плоскости,`}
          </LatexText>

          <div className="my-4">
              <MathFormula 
                formula="T = 
                \begin{bmatrix}
                x_1 & y_1 & t_1\\
                x_2 & y_2 & t_2 \\
                x_3 & y_3 & t_3\\ 
                \end{bmatrix}"
                displayMode={true}
              />
            </div>

            <LatexText className = "mb-4">
          {`T - некоторая матрица (оператор) преобразования, где все элементы матрицы из $\\mathbb{R}$. Напомним, что в матрицах преобразования каждая строчка отвечает за одну координату образа точки, в данном случае у матрицы $T$ первая строчка отвечает за $x \\in A'$, вторая строчка отвечает за $y \\in A'$, а третья строчка отвечает за проективную координату $t \\in A'$, которая так же отвечает за пропорциональность. Значения в столбцах умножаются на соответствующую координату исходной точки $A$, т.е. значения первого столбца умножаются на $x \\in A$, значения второго столбца умножаются на $y \\in A$ и значения третьего столбца умножаются на $t \\in A$. Расширим координаты точки до $A = (a_1, a_2, 1)$, т.е. до однородных координат. При преобразовании матрицей $T$, точке $A$ ставится в соответствии её образ $A' = (a_1', a_2', a_3')$, где $a_1'$, $a_2'$ и $a_3'$ - координаты точки $A'$`}.
          </LatexText>

          <p className = "mb-4">Таким образом получаем, что:</p>

          <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    A' = T \cdot A = \begin{bmatrix}
    x_1 & y_1 & t_1\\
    x_2 & y_2 & t_2 \\
    x_3 & y_3 & t_3
    \end{bmatrix}
    \cdot 
\begin{bmatrix}
    a_1 \\
    a_2 \\
    1
\end{bmatrix}
= \begin{bmatrix}
    a_1' \\
    a_2' \\
    a_3'
\end{bmatrix}
\end{equation*}"
                displayMode={true}
              />
            </div>


            <p className = "mb-4">
            Данное равенство для простоты можно записать в виде следующей системы:
            </p>
            

            <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    \begin{cases}
        a_1' = x_1\cdot a_1 + y_1\cdot a_2 + t_1 \\
        a_2' = x_2\cdot a_1 + y_2\cdot a_2 + t_2 \\
        a_3' = x_3\cdot a_1 + y_3\cdot a_2 + t_3
    \end{cases}
\end{equation*}"
                displayMode={true}
              />
            </div>

            <LatexText className = "mb-4">
            Отсюда мы получаем координаты для точки $A'$, подставляем их и получим:
            </LatexText>



            <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    A' =
    \begin{bmatrix}
        a_1' \\
        a_2' \\
        a_3'
    \end{bmatrix}
    =
    \begin{bmatrix}
        x_1\cdot a_1 + y_1\cdot a_2 + t_1 \\
        x_2\cdot a_1 + y_2\cdot a_2 + t_2 \\
        x_3\cdot a_1 + y_3\cdot a_2 + t_3
    \end{bmatrix}
\end{equation*}"
                displayMode={true}
              />
            </div>


            <LatexText className = "mb-4">
            Так как до этого мы работали в однородных координатах, необходимо привести третью координату точку $A'$ к единице, для этого делим все координаты точки на $a_3' = x_3\cdot a_1 + y_3\cdot a_2 + t_3$ и получим:
            </LatexText>


            <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    A' =
    \begin{bmatrix}
        \frac{a_1'}{a_3'} \\[7pt]
        \frac{a_2'}{a_3'} \\[7pt]
        1
    \end{bmatrix}
    =
    \begin{bmatrix}
        \frac{x_1\cdot a_1 + y_1\cdot a_2 + t_1}{x_3\cdot a_1 + y_3\cdot a_2 + t_3} \\[8pt]
        \frac{x_2\cdot a_1 + y_2\cdot a_2 + t_2}{x_3\cdot a_1 + y_3\cdot a_2 + t_3} \\[8pt]
        1
    \end{bmatrix}
\end{equation*}"
                displayMode={true}
              />
            </div>


            <LatexText className = "mb-4">
            Переводя в обычные координаты, точку $A'$ можно записать в виде:
            </LatexText>


            <div className="my-4">
              <MathFormula 
                formula="\begin{equation}
    A' = \left(\frac{x_1\cdot a_1 + y_1\cdot a_2 + t_1}{x_3\cdot a_1 + y_3\cdot a_2 + t_3},  \frac{x_2\cdot a_1 + y_2\cdot a_2 + t_2}{x_3\cdot a_1 + y_3\cdot a_2 + t_3}\right)
\end{equation}"
                displayMode={true}
              />
            </div>

            <LatexText className = "mb-4">
            Таким образом были получены координаты нового образа точки, которые зависят от координат точки $A$ и элементов матрицы преобразования $T$.
            </LatexText>




            <h2 className="text-2xl font-bold mb-4">Матрица параллельного переноса</h2>

            <p className = "mb-4">
          Матрицей параллельного переноса является матрица вида
          </p>


            <div className="my-4">
              <MathFormula 
                formula="T =
\begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>

          <LatexText className = "mb-4">
          Данная матрица работает следующим образом:
          
          Пусть дана точка $A = (a_1,\,a_2)$, тогда образ $A' = T \cdot A$ будет задаваться следующими координатами: $A' = (a_1+t_x,\,a_2+t_y)$. Стоит отметить, что знаменатель никуда не делся, т.к. сами координаты точки $A'$ делятся на $0\cdot a_1 + 0\cdot a_2 + 1 = 1$, из-за чего знаменатель был опущен.
          </LatexText>

          <h2 className="text-2xl font-bold mb-4">Матрица поворота</h2>


          <p className = "mb-4">
          Матрицей поворота является матрица вида
          </p>

            <div className="my-4">
              <MathFormula 
                formula="T =
\begin{bmatrix}
    \cos{\alpha}&\mp\sin{\alpha}&0\\[2pt]
    \pm\sin{\alpha}&\cos{\alpha}&0\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>


            <LatexText className = "mb-4">
              {`У данной матрицы есть свойство, что при повороте против часовой стрелки угол $\\alpha > 0$ (т.е. растёт), а при повороте по часовой стрелке угол $\\alpha < 0$ (т.е. убывает), при движении это означает, что угол $\\alpha$ растёт или убывает соответственно. Данная матрица преобразования вращает точку вокруг центра координат, но как же вращать точку вокруг иного центра вращения, отличного от $(0,\\,0)$? Для начала рассмотрим образ точки $A' = (\\cos({\\alpha})\\cdot a_1\\mp\\sin({\\alpha})\\cdot a_2,\\, \\pm\\sin({\\alpha})\\cdot a_1+\\cos({\\alpha})\\cdot a_2)$, полученный при умножении матрицы поворота $T$ на исходную точку $A$ и сведению однородных координат к обычным. Обозначим первую и вторую координату через $\\gamma_1$ и $\\gamma_2$ соответственно. Если мы перенесём данную точку, прибавив к координатам числа $s_x$ и $s_y$ соответственно, получим $A' = (\\gamma_1 + s_x,\\, \\gamma_2 + s_y)$. Данные координаты напоминают координаты точки $A' = (a_1+t_x,\\,a_2+t_y)$, полученные после совершения операции параллельного переноса. Подставляя вместо $\\gamma_1$ и $\\gamma_2$ исходные координаты, точка $A' = (\\cos({\\alpha})\\cdot a_1\\mp\\sin({\\alpha})\\cdot a_2 + s_x,\\, \\pm\\sin({\\alpha})\\cdot a_1+\\cos({\\alpha})\\cdot a_2 + s_y)$ Таким образом точка $A'$ будет вращаться вокруг нового центра $S = (s_x,\\,s_y)$. Так же можно записать данную точку иначе: $A' = (s_x - (\\cos({\\alpha})\\cdot a_1\\mp\\sin({\\alpha})\\cdot a_2),\\, s_y - (\\pm\\sin({\\alpha})\\cdot a_1+\\cos({\\alpha})\\cdot a_2))$, но тогда образ точки (объекта) будет зеркально отражён относительно центра вращения $S$ и направлен в противоположную сторону вращения, т.е. ''развернётся'' на 180 градусов. Данный разворот не несёт ничего критичного, объект всё так же вращается в правильном направлении при убывающем или возрастающем значении угла $\\alpha$.`}
            </LatexText>

            <h2 className="text-2xl font-bold mb-4">Матрица масштабирования</h2>

            <p className = "mb-4">Матрица масштабирования записывается в виде</p>

            <div className="my-4">
              <MathFormula 
                formula="T =
\begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>

            <LatexText className = "mb-4">
            Где $k_x,\,k_y$ - коэффициенты масштабирования. Матрица масштабирования может ''увеличивать'' или ''сжимать'' объект относительно заданного центра или центра координат, если коэффициенты масштабирования равны друг другу. Если коэффициенты имеют разные значения, то преобразования будет растягивать объект вдоль одной из осей. Если же коэффициенты имеют отрицательное значение, то новый образ объекта будет зеркально отражён относительно осей $Ox$ или $Oy$. Если же оба коэффициенты равны нулю, то новый образ объекта стянется в точку, которая будет находиться либо в центре координатной оси, либо в заданном центре. Если же один из коэффициентов равен нулю, то образ ''ляжет'' на ось координат и станет отрезком.
            </LatexText>

            <LatexText className = "mb-4">
            Если рассматривать координаты точки $A'$ из формулы (1), то координаты точки $A' = (k_x\cdot a_1,\, k_y\cdot a_2)$
            </LatexText>

            <h2 className="text-2xl font-bold mb-4">Матрица наклона</h2>

            <p className = "mb-4">Матрицей наклона является матрица вида</p>

            <div className="my-4">
              <MathFormula 
                formula="T =
\begin{bmatrix}
    1&g_x&0\\[2pt]
    g_y&1&0\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>


            <LatexText className = "mb-4">
            Где $g_x,\,g_y$ - коэффициенты наклона. Данная матрица преобразования может как наклонять объекты с одной или несколькими фиксированными точками, так и растягивать их по сторонам. Данная матрица может преобразовать объект в некоторый отрезок, если коэффициенты $g_x = g_y = \pm 1$. Если быть конкретнее, то если коэффициенты равны $1$, то объект ложится отрезком на прямую $y = x$. Либо, если оба коэффициента равняются $-1$, объект ложится отрезком уже на прямую $y = -x$. Если же оба коэффициента равняются нулю, то мы получаем тождественную матрицу преобразования.
            </LatexText>


            <LatexText className = "mb-4">
            Если воспользоваться общим видом координат точки $A'$ по формуле (1), то подставив значения матрицы $T$ получим $A' = (a_1+g_x\cdot a_2,\, g_y\cdot a_1 + a_2)$.
            </LatexText>


            <h2 className="text-2xl font-bold mb-4">Композиция матриц преобразования</h2>

            <LatexText className="mb-4">Композицией операторов преобразований (или умножение матриц преобразований) осуществляется путем последовательного произведения матриц преобразований. Из курса линейной алгебры известно, что матрицы не коммутативны (т.е. перестановка матриц в произведении даст неоднозначный результат), но матрицы являются ассоциативным в произведении, т.е. $(A\cdot B)\cdot C = A\cdot (B \cdot C)$. Если при работе с геометрическим объектом необходимо применить сразу несколько операторов преобразования, то можно воспользоваться формулой: $(T_1 \circ T_2 \circ T_3 \circ \dots \circ T_n)(A) = T_1(T_2(T_3(\dots(T_n(A))\dots)))$, где $T_1,\,T_2,\,\dots,\,T_n$ - матрицы преобразования, $A$ - некоторая вершина объекта.</LatexText>

            <LatexText className="mb-4">{`Рассмотрим два одинаковых примера, в которых будет показано вычисление новых координат одной точки двумя способами. Пусть $A = (a_1,\\,a_2)$ - некоторая точка в пространстве $\\mathbb{R}^2$. Пусть матрица масштабирования`}</LatexText>

            <div className="my-4">
              <MathFormula 
                formula="T_1 =
\begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>

            <LatexText className="mb-4">применяется к точке $A$ в первую очередь, а затем применяется матрица параллельного переноса</LatexText>

            <div className="my-4">
              <MathFormula 
                formula="T_2 =
\begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
\end{bmatrix}"
                displayMode={true}
              />
            </div>

            <LatexText className="mb-4">Приведём точку $A$ к однородным системам координат: $A = (a_1,\,a_2,\,1)$</LatexText>

            <p className="mb-4">Первый способ вычисления:</p>

            <div className="my-4">
              <MathFormula 
                formula="\begin{align*}
    A' &= T_2 \cdot \left(T_1 \cdot A\right) =
    \begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \left(
    \begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        a_1\\
        a_2\\
        1
    \end{bmatrix}
    \right)\\
    &=
    \begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
    a_1 + t_x \\
    a_2 + t_y \\
    1
    \end{bmatrix}
    = \begin{bmatrix}
        k_x \cdot (a_1 + t_x)\\[2pt]
        k_y \cdot (a_2 + t_y)\\[2pt]
        1
    \end{bmatrix}\\
    &\Rightarrow A' = (k_x \cdot (a_1 + t_x),\,k_y \cdot (a_2 + t_y)).
\end{align*}"
                displayMode={true}
              />
            </div>

            <p className="mb-4">Второй способ вычисления:</p>

            <div className="my-4">
              <MathFormula 
                formula="\begin{align*}
    A' &= \left(T_2 \cdot T_1\right) \cdot A = \left(
    \begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
    \end{bmatrix}
    \right)
    \cdot
    \begin{bmatrix}
        a_1\\
        a_2\\
        1
    \end{bmatrix}
    \\
    &=
    \begin{bmatrix}
        k_x & 0 & k_x\cdot t_x\\[2pt]
        0 & k_y & k_y \cdot t_y\\[2pt]
        0 & 0 & 1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        a_1\\
        a_2\\
        1
    \end{bmatrix}
    =   \begin{bmatrix}
        k_x \cdot a_1 + k_x \cdot t_x\\
        k_y \cdot a_2 + k_y \cdot t_y\\
        1
    \end{bmatrix}
    \\
    &\Rightarrow A' = (k_x \cdot (a_1 + t_x),\,k_y \cdot (a_2 + t_y)).
\end{align*}"
                displayMode={true}
              />
            </div>

            <p className="mb-4">Таким образом мы просто показали, что порядок скобок не важен. Однако отметим, что порядок применения матриц преобразования важен. Если к вершинам геометрической фигуры сначала применить матрицу масштабирования, а затем поворота, то результатом будет поворот масштабированной фигуры. Если же поменять эти матрицы местами, но так как матрицы не коммутативны по умножению, то и результат такого преобразования будет совершенно другим.</p>

            <p className="mb-4">Пример перестановок произведения двух матриц преобразования:</p>

            <ol className="list-decimal mb-4 ml-6">
              <li><div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    \begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
    \end{bmatrix}
    =
    \begin{bmatrix}
        k_x & 0 & k_x\cdot t_x\\[2pt]
        0 & k_y & k_y \cdot t_y\\[2pt]
        0 & 0 & 1
    \end{bmatrix}
\end{equation*}"
                displayMode={true}
              />
            </div></li>
              <li><div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    \begin{bmatrix}
    1&0&t_x\\[2pt]
    0&1&t_y\\[2pt]
    0&0&1
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
    k_x&0&0\\[2pt]
    0&k_y&0\\[2pt]
    0&0&1
    \end{bmatrix}
    =
    \begin{bmatrix}
        k_x & 0 & t_x\\[2pt]
        0 & k_y & t_y\\[2pt]
        0 & 0 & 1
    \end{bmatrix}
\end{equation*}"
                displayMode={true}
              />
            </div></li>
            </ol>

            <LatexText className="mb-4">Применив разные результаты умножения матриц к точке $A = (a_1,\,a_2,\,1)$ получим:</LatexText>

            <p className="mb-4">Масштабирование переноса:</p>

            <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    A' = (k_x \cdot (a_1 + t_x),\,k_y \cdot (a_2 + t_y)).
\end{equation*}"
                displayMode={true}
              />
            </div>

            <p className="mb-4">Перенос масштабирования:</p>

            <div className="my-4">
              <MathFormula 
                formula="\begin{equation*}
    A' = (k_x \cdot a_1 + t_x,\,k_y \cdot a_2 + t_y).
\end{equation*}"
                displayMode={true}
              />
            </div>

            <p className="mb-4">Отсюда следует вывод, что последовательность матриц преобразований играет важную роль, так как нельзя взять и поменять матрицы местами, ожидая при этом получить такое же преобразование. При написании кода это стоит учитывать, так как неправильно заданная последовательность может привести к иному преобразованию, отличного от ожидаемого. </p>



            

          </>
        );

      case 'color-theory':
        return (
          <>
            <h2 className="text-2xl font-bold mb-4">{t('colorTheoryTitle')}</h2>
            <p className="mb-4">{t('colorTheoryContent')}</p>
            
            <div className="grid grid-cols-3 gap-4 my-4">
              <div className="bg-red-500 h-20 rounded-md flex items-center justify-center text-white">RGB</div>
              <div className="bg-yellow-500 h-20 rounded-md flex items-center justify-center text-white">CMYK</div>
              <div className="bg-blue-500 h-20 rounded-md flex items-center justify-center text-white">HSV</div>
            </div>

            <h2 className="text-2xl font-bold mb-4">{'RGB'}</h2>
            
            <p className="mb-4">RGB - это цветовая модель, представляющая собой вектор с тремя координатами (R, G, B), где R - красный, G - зеленый, B - синий. Обычно данная модель 8-битная, т.е. каждый цвет принимает значения в диапазоне [0, 255], т.е. 256 оттенков на каждый цвет. Разновидностью данной цветовой модели являются 16-битные модели и HDR (32-битные модели). Иногда RGB модель записывается в шестнадцатеричном формате (0xRRGGBB), принимающий значения в шестнадцатеричном диапазоне [0, F].</p>
            
            <p className="mb-4">RGB рассчитана на создание цвета на экране компьютера или мониторе. RGB часто используется в веб-дизайне, видеообработке и фотографий для создания ярких и насыщенных изображений. Эта модель также лежит в основе работы многих графических редакторов, таких как Photoshop или GIMP</p>
            
            <figure>
            <img
            src = "src/imgs/RGB-color-model.jpg"
            alt="RGB"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Круги RGB и их пересечения</figcaption>
            </figure>


            <h6 className="font-bold mb-4">Преимущества модели RGB:</h6>
            <ol className="list-decimal ml-6 mb-4">
              <li>Простота. Модель RGB довольно проста и наглядна в понимании и в своем представлении, данная цветовая модель из-за своей простоты используется в мониторах компьютера и цифровых дисплеях, т.к. для кодировки цвета достаточно трёх пикселей, отвечающих за разные цветовые каналы.</li>
              <li>Яркая и насыщенная цветовая гамма.</li>
            </ol>
            
            <h6 className="font-bold mb-4">Недостатки модели RGB:</h6>
            
              <ol className="list-decimal mb-4 ml-6">
                <li>Недостаточность цветового охвата. Независимо от размера цветового пространства модели цвета RGB, в ней невозможно воспроизвести много воспринимаемых глазом цветов (например, спектрально чистые голубой и оранжевый). У таких цветов в формуле цвета RGB имеются отрицательные значения интенсивностей базового цвета, а реализовать не сложение, а вычитание базовых цветов при технической реализации аддитивной модели очень сложно.</li>
                <li>Качество и насыщенность цвета зависит от технических характеристик устройства, выводящего на экран изображение.</li>
              </ol>
            
            <h2 className="text-2xl font-bold mb-4">{'CMYK'}</h2>

            
            <p className = "mb-4">CMYK - Цветовая модель, расшифровывающаяся как Cyan (Голубой), Magenta (Пурпурный), Yellow (Желтый) и Key/Black (Черный). Данная цветовая модель используется в основном в полиграфии. Результат применения CMYK зависит не только от спектральных характеристик, но и от типа бумаги и от способа нанесения красок. В отличие от модели RGB, числовые значения в CMYK определяются процентным содержанием какого-либо цвета. На пример, значение (60, 10, 30, 5) будет означать 60-голубой, 10-пурпурный, 30-желтый, 5-черный. Иногда записывается в другом формате: C60M10Y30K5. В оптимизированном случае чёрная составляющая полностью компенсирует максимально равные доли цветных красителей так, что при определении любого цвета как минимум один цветной компонент равен нулю. То есть цвет (30, 45, 80, 5) оптимизируется в (0, 15, 50, 35). На изображениях ниже представлен пример такой оптимизации.</p>
            
            <figure>
            <img
            src = "src/imgs/CMYK.png"
            alt="CMYK"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Графическая интерпретация CMYK</figcaption>
            </figure>


            <figure>
            <img
            src = "src/imgs/CMYK_bef_opti.png"
            alt="CMYK_bef"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Значения CMYK до оптимизации</figcaption>
            </figure>


            <figure>
            <img
            src = "src/imgs/CMYK_after_opti.png"
            alt="CMYK_after"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Значения CMYK после оптимизации</figcaption>
            </figure>
            
            <p className = "mb-4">Цветовую модель CMYK описать числами просто так не получится, т.к. ранее был представлен лишь процентное соотношение цвета в краске, а результат зависит от состояния печатной машины, бумаги, влажности в воздухе и т.д. Для описания модели CMYK более точными значениями применяются другие профили, такие как XYZ, LAB, ICC и другие.</p>
            
            <h6 className="font-bold mb-4">Недостатки модели CMYK:</h6>
            <ol className="list-decimal mb-4 ml-6">
              <li>Так как CMYK используется для цветной печати, то цвет изображений, цвета которых кодируются в формате RGB, может быть искажен или не таким ярким.</li>
            </ol>





            <h2 className="text-2xl font-bold mb-4">{'HSV (HSB)'}</h2>

            <LatexText className="mb-4">
              {`Цветовая модель HSB - Цветовая модель HSB (или же HSV) представляет собой набор из трёх компонент: Hue -  оттенок или тон цвета (красный, синий, зелёны), Saturation - насыщенность, Brightness (Value) - яркость цвета. Тон в данной цветовой модели в числовом формате определяется следующим образом: $0 \\leq H < 360$, либо $0 \\leq H < 100$ или $0 \\leq H < 1$; насыщенность принимает значения в диапазоне $0 \\leq S \\leq 100$ или $0 \\leq S \\leq 1$, аналогично и для яркости $B$ (или же $V$). Эта модель разработана для первых графических редакторов еще в 90-х годах. Цвет, представленный в HSB, зависит от устройства, на которое он будет выведен, так как HSB — преобразование модели RGB, которая тоже зависит от устройства. Для получения кода цвета, не зависящего от устройства, используется модель Lab.`}
            </LatexText>

            <p className = "mb-4">Это простая и понятная модель, однако ее можно использовать только для виртуальной графики. Она не совмещается с печатными устройствами, хотя и является наиболее охватывающей в сравнении с другими. Часто такую модель применяют для создания линейных (примитивных) компьютерных мультфильмов, при оформлении картинок в соцсетях и т.п.</p>
            
            <figure>
            <img
            src = "src/imgs/HSB_cylinder.jpg"
            alt="HSB_cyl"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Графическая интерпретация HSV (HSB) в виде цилиндра</figcaption>
            </figure>


            <figure>
            <img
            src = "src/imgs/HSV_cone.png"
            alt="HSV_cone"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Графическая интерпретация HSV (HSB) в виде конуса</figcaption>
            </figure>


            <figure>
            <img
            src = "src/imgs/Triangulo_HSV.png"
            alt="Triangulo_HSV"
            className="w-full max-w-2xl h-auto rounded-lg shadow-md my-4"></img>
            <figcaption>Цветовой круг модели HSV (HSB)</figcaption>
            </figure>



          </>
        );
      
      default:
        return (
          <div className="text-center text-gray-500">
            <p>Select a topic from the navigation panel</p>
          </div>
        );
    }
  };

  return (
    <Card className="w-full h-full bg-gray-100 rounded-lg shadow-md">
      <ScrollArea className="h-[calc(100vh-140px)] w-full">
        <CardContent className="p-6">
          <div className="prose prose-gray max-w-none">
            {renderTopicContent()}
          </div>
        </CardContent>
        <ScrollBar orientation="horizontal" />
        <ScrollBar orientation="vertical" />
      </ScrollArea>
    </Card>
  );
};

export default MainPanel;
